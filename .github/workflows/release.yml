# n3x Release Pipeline — build and publish ISAR images for all supported machines
#
# Trigger: Push of a version tag (e.g., "0.0.1", "1.2.3-rc1").
# Tags are created automatically by auto-tag.yml when the VERSION file
# changes on main. To release: update VERSION in a PR, merge to main.
# No manual tag creation required.
#
# The tag MUST match the content of the VERSION file at the tagged commit
# (enforced by the validate job below).
#
# Release scope: base/production images for all 4 machines (5 variants, 9 assets).
# Profile-specific server/agent images are excluded — users build those locally.
#
# Workflow:
#   1. Validate: tag == VERSION file
#   2. Build: kas-build per-machine (parallel across runners)
#   3. Collect: rename artifacts to release naming, upload
#   4. Release: create GitHub Release, attach all assets
#
# Release asset naming: n3x-{variant}-{machine}-{version}{ext}
#   e.g., n3x-base-qemuamd64-0.0.1.wic.zst
#
# See also: auto-tag.yml (creates tags from VERSION file changes)

name: Release

on:
  push:
    tags: ['[0-9]*']

# Only one release at a time
concurrency:
  group: release
  cancel-in-progress: false

jobs:
  # ===========================================================================
  # Step 1 — Validate tag matches VERSION file
  # ===========================================================================

  validate:
    name: Validate release tag
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      version: ${{ steps.check.outputs.version }}
    steps:
      - uses: actions/checkout@v4

      - name: Validate tag matches VERSION
        id: check
        run: |
          TAG="${GITHUB_REF_NAME}"
          VERSION=$(cat VERSION)
          echo "Tag: $TAG"
          echo "VERSION file: $VERSION"

          if [ "$TAG" != "$VERSION" ]; then
            echo "::error::Tag '$TAG' does not match VERSION file '$VERSION'"
            echo "::error::Update VERSION to '$TAG' and re-tag, or delete the tag and fix."
            exit 1
          fi

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Tag and VERSION match: $VERSION"

  # ===========================================================================
  # Step 2 — Build release images per machine
  #
  # Each machine builds its release-scope variants, renames outputs to
  # release naming, and uploads as GitHub Actions artifacts.
  # ===========================================================================

  build:
    name: "Build: ${{ matrix.machine }}"
    needs: validate
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 120
    strategy:
      fail-fast: true
      matrix:
        include:
          - machine: qemuamd64
            runner: ubuntu-latest
          - machine: qemuarm64
            runner: ubuntu-24.04-arm
          - machine: amd-v3c18i
            runner: ubuntu-latest
          - machine: jetson-orin-nano
            runner: ubuntu-24.04-arm
    steps:
      - name: Free disk space (x86_64)
        if: runner.arch == 'X64'
        uses: jlumbroso/free-disk-space@v1.3.1
        with:
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: false
          swap-storage: false
          tool-cache: false

      - name: Free disk space (ARM64)
        if: runner.arch == 'ARM64'
        run: |
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /usr/local/share/powershell 2>/dev/null || true
          sudo apt-get autoremove -y 2>/dev/null || true
          df -h /

      - uses: actions/checkout@v4
      - uses: cachix/install-nix-action@v31

      - name: Install kas
        run: pip install kas==5.1

      - name: Restore download cache
        uses: actions/cache@v4
        with:
          path: .ci-cache/downloads
          key: isar-dl-${{ runner.arch }}-${{ hashFiles('backends/debian/kas/**') }}
          restore-keys: isar-dl-${{ runner.arch }}-

      - name: Restore sstate cache
        uses: actions/cache@v4
        with:
          path: .ci-cache/sstate
          key: isar-sstate-${{ matrix.machine }}-${{ hashFiles('backends/debian/kas/**', 'backends/debian/meta-n3x/**') }}
          restore-keys: isar-sstate-${{ matrix.machine }}-

      - name: Prepare cache directories
        run: mkdir -p .ci-cache/downloads .ci-cache/sstate

      - name: Build and collect release artifacts
        env:
          KAS_CONTAINER_ENGINE: docker
          KAS_CONTAINER_IMAGE: ghcr.io/siemens/kas/kas-isar:5.1
          DL_DIR: ${{ github.workspace }}/.ci-cache/downloads
          SSTATE_DIR: ${{ github.workspace }}/.ci-cache/sstate
          MACHINE: ${{ matrix.machine }}
          VERSION: ${{ needs.validate.outputs.version }}
        working-directory: backends/debian
        run: |
          set -euo pipefail

          DEPLOY_DIR="build/tmp/deploy/images/$MACHINE"
          RELEASE_DIR="$GITHUB_WORKSPACE/release-assets"
          mkdir -p "$RELEASE_DIR"

          # All variant metadata from build-matrix.nix: kas commands (with CI
          # overlays), ISAR output filenames, and release asset names.
          HOST_ARCH=$(uname -m)
          VARIANTS=$(nix eval --json '.#lib.debian.buildMatrix' --apply "
            matrix: builtins.map (v: {
              id = matrix.mkVariantId v;
              kasCommand = matrix.mkCiKasCommand { hostArch = \"$HOST_ARCH\"; } v;
              artifacts = builtins.map (ext: {
                isarFile = matrix.mkReleaseIsarOutputName v ext;
                releaseName = matrix.mkReleaseAssetName { version = \"$VERSION\"; } v ext;
                optional = ext == \".wic.bmap\";
              }) matrix.machines.\${v.machine}.releaseExtensions;
            }) (builtins.filter (v: v.machine == \"$MACHINE\") matrix.releaseVariants)
          ")

          VARIANT_COUNT=$(echo "$VARIANTS" | jq 'length')
          echo "Building $VARIANT_COUNT release variants for $MACHINE (host: $HOST_ARCH)"

          for IDX in $(seq 0 $((VARIANT_COUNT - 1))); do
            ID=$(echo "$VARIANTS" | jq -r ".[$IDX].id")
            KAS_CMD=$(echo "$VARIANTS" | jq -r ".[$IDX].kasCommand")

            echo "::group::[$((IDX + 1))/$VARIANT_COUNT] Build: $ID"
            echo "kas command: $KAS_CMD"

            # Clean stale .git-downloads symlink
            rm -f build/tmp/work/debian-trixie-*/.git-downloads 2>/dev/null || true

            kas-container --isar build "$KAS_CMD"

            # Collect release artifacts immediately (before next build overwrites
            # shared output filename — base and base-swupdate produce same filename)
            ARTIFACT_COUNT=$(echo "$VARIANTS" | jq ".[$IDX].artifacts | length")
            for AIDX in $(seq 0 $((ARTIFACT_COUNT - 1))); do
              ISAR_FILE=$(echo "$VARIANTS" | jq -r ".[$IDX].artifacts[$AIDX].isarFile")
              RELEASE_NAME=$(echo "$VARIANTS" | jq -r ".[$IDX].artifacts[$AIDX].releaseName")
              OPTIONAL=$(echo "$VARIANTS" | jq -r ".[$IDX].artifacts[$AIDX].optional")

              ISAR_PATH="${DEPLOY_DIR}/${ISAR_FILE}"
              if [ ! -f "$ISAR_PATH" ]; then
                # .wic.bmap is auto-generated by ISAR's WIC builder (--bmap flag).
                # If it's missing, warn but don't fail — the .wic.zst is the
                # primary artifact and bmap is a flashing optimization.
                if [ "$OPTIONAL" = "true" ]; then
                  echo "::warning::Optional artifact not found: $ISAR_PATH (bmap is auto-generated by WIC builder)"
                  ls -la "$DEPLOY_DIR/"*bmap* 2>/dev/null || echo "  No bmap files in deploy dir"
                  continue
                fi
                echo "::error::Expected artifact not found: $ISAR_PATH"
                ls -la "$DEPLOY_DIR/" 2>/dev/null || true
                exit 1
              fi

              cp "$ISAR_PATH" "$RELEASE_DIR/$RELEASE_NAME"
              echo "  $RELEASE_NAME ($(du -h "$RELEASE_DIR/$RELEASE_NAME" | cut -f1))"
            done

            echo "::endgroup::"
          done

          echo ""
          echo "=== Release artifacts for $MACHINE ==="
          ls -lh "$RELEASE_DIR/"

      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.machine }}
          path: release-assets/
          retention-days: 1
          if-no-files-found: error

      - name: Show disk usage
        if: always()
        run: |
          echo "=== Disk usage ==="
          df -h /
          echo ""
          echo "=== Cache sizes ==="
          du -sh .ci-cache/downloads/ .ci-cache/sstate/ 2>/dev/null || echo "No cache data"

  # ===========================================================================
  # Step 3 — Create GitHub Release and upload assets
  # ===========================================================================

  release:
    name: Create release
    needs: [validate, build]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed for conventional commit parsing
          fetch-tags: true

      - name: Download all release artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: release-*
          path: release-assets/
          merge-multiple: true

      - name: List release assets
        run: |
          echo "=== Release assets ==="
          ls -lh release-assets/
          echo ""
          echo "Total: $(ls release-assets/ | wc -l) files"

      - name: Generate release notes from conventional commits
        env:
          VERSION: ${{ needs.validate.outputs.version }}
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"

          # Find previous tag (second most recent version tag)
          PREV_TAG=$(git tag --sort=-version:refname | grep -E '^[0-9]' | sed -n '2p')

          if [ -n "$PREV_TAG" ]; then
            RANGE="${PREV_TAG}..${TAG}"
            echo "Generating notes for commits in: $RANGE"
          else
            # First release: all commits reachable from tag
            RANGE="$TAG"
            echo "First release: including all commits"
          fi

          # Collect commit subjects (skip merge commits)
          mapfile -t SUBJECTS < <(git log --format="%s" --no-merges "$RANGE")
          echo "Found ${#SUBJECTS[@]} commits to process"

          # Ordered type list: type:display_name
          TYPES=(
            "feat:Features"
            "fix:Bug Fixes"
            "perf:Performance"
            "refactor:Refactoring"
            "docs:Documentation"
            "test:Tests"
            "ci:CI"
            "build:Build"
            "style:Style"
            "chore:Chores"
          )

          # Create temp files for each section
          TMPDIR=$(mktemp -d)
          trap 'rm -rf "$TMPDIR"' EXIT
          for TYPE_PAIR in "${TYPES[@]}"; do
            touch "$TMPDIR/${TYPE_PAIR%%:*}"
          done
          touch "$TMPDIR/breaking" "$TMPDIR/other"

          # Parse each commit subject
          CC_REGEX='^(feat|fix|docs|ci|test|refactor|chore|build|perf|style)(\(([^)]+)\))?(!)?: (.+)$'
          for SUBJECT in "${SUBJECTS[@]}"; do
            if [[ "$SUBJECT" =~ $CC_REGEX ]]; then
              TYPE="${BASH_REMATCH[1]}"
              SCOPE="${BASH_REMATCH[3]}"
              BREAKING="${BASH_REMATCH[4]}"
              DESC="${BASH_REMATCH[5]}"

              if [ -n "$SCOPE" ]; then
                echo "- **$SCOPE**: $DESC" >> "$TMPDIR/$TYPE"
              else
                echo "- $DESC" >> "$TMPDIR/$TYPE"
              fi

              if [ -n "$BREAKING" ]; then
                if [ -n "$SCOPE" ]; then
                  echo "- **$SCOPE**: $DESC" >> "$TMPDIR/breaking"
                else
                  echo "- $DESC" >> "$TMPDIR/breaking"
                fi
              fi
            else
              # Non-conventional commit (e.g., epoch commits from initial import)
              echo "- $SUBJECT" >> "$TMPDIR/other"
            fi
          done

          # Assemble release notes
          {
            echo "## What's Changed"
            echo ""

            if [ -s "$TMPDIR/breaking" ]; then
              echo "### Breaking Changes"
              echo ""
              cat "$TMPDIR/breaking"
              echo ""
            fi

            for TYPE_PAIR in "${TYPES[@]}"; do
              TYPE="${TYPE_PAIR%%:*}"
              DISPLAY="${TYPE_PAIR#*:}"
              if [ -s "$TMPDIR/$TYPE" ]; then
                echo "### $DISPLAY"
                echo ""
                cat "$TMPDIR/$TYPE"
                echo ""
              fi
            done

            if [ -s "$TMPDIR/other" ]; then
              echo "### Other Changes"
              echo ""
              cat "$TMPDIR/other"
              echo ""
            fi

            if [ -n "$PREV_TAG" ]; then
              echo "**Full changelog**: https://github.com/$GITHUB_REPOSITORY/compare/${PREV_TAG}...${TAG}"
            fi
          } > release-notes.md

          echo ""
          echo "=== Generated release notes ==="
          cat release-notes.md

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
          VERSION: ${{ needs.validate.outputs.version }}
        run: |
          TAG="${GITHUB_REF_NAME}"

          gh release create "$TAG" \
            --title "n3x $VERSION" \
            --notes-file release-notes.md \
            release-assets/*

          echo ""
          echo "Release created: https://github.com/$GITHUB_REPOSITORY/releases/tag/$TAG"
