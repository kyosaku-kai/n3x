# GRUB Configuration for A/B Rootfs with SWUpdate
#
# This configuration supports A/B partition switching via grubenv.
# SWUpdate sets rootfs_slot variable after applying updates.
#
# Variables in grubenv:
#   rootfs_slot = "a" or "b" - which rootfs to boot
#   boot_count = number of boot attempts (for rollback logic)
#
# Partition layout (from sdimage-efi-ab.wks):
#   Partition 1: EFI (ESP) - this config lives here
#   Partition 2: APP (rootfs-a) - LABEL=APP
#   Partition 3: APP_b (rootfs-b) - LABEL=APP_b
#   Partition 4: data (persistent) - LABEL=data

# Serial console setup (optional - may not be available in headless QEMU)
# If serial is not available, GRUB falls back to console-only
serial --unit=0 --speed=115200 --word=8 --parity=no --stop=1 || true
terminal_input console
terminal_output console

# Default values if grubenv doesn't exist or is corrupted
set default=0
set timeout=5
set timeout_style=menu
set rootfs_slot=a

# Try to load environment from grubenv file
# GRUB searches EFI partition by default
if [ -f /EFI/BOOT/grubenv ]; then
    load_env -f /EFI/BOOT/grubenv
fi

# Select root partition based on slot
if [ "$rootfs_slot" = "b" ]; then
    set rootfs_label=APP_b
    set slot_name="B"
else
    set rootfs_label=APP
    set slot_name="A"
fi

# Save the boot partition (EFI) for kernel loading
# GRUB starts with root set to EFI partition by default
set boot_partition=$root

# Load regexp module for glob pattern matching in for loops
insmod regexp

# Find kernel and initrd files (they have version suffixes like vmlinuz-6.12.xxx)
# GRUB2 requires insmod regexp for glob wildcards in for loops
# The bootimg-efi-isar plugin copies versioned files from /boot
set kernel_file=""
set initrd_file=""

# Try versioned kernel/initrd first (Debian convention)
for k in /vmlinuz-*; do
    if [ -f "$k" ]; then
        set kernel_file="$k"
        break
    fi
done
for i in /initrd.img-*; do
    if [ -f "$i" ]; then
        set initrd_file="$i"
        break
    fi
done

# Fallback to non-versioned names (if symlinks exist)
if [ -z "$kernel_file" ]; then
    if [ -f /vmlinuz ]; then
        set kernel_file="/vmlinuz"
    fi
fi
if [ -z "$initrd_file" ]; then
    if [ -f /initrd.img ]; then
        set initrd_file="/initrd.img"
    fi
fi

# Main boot entry
menuentry "n3x (slot $slot_name)" {
    echo "Booting from rootfs slot $slot_name (LABEL=$rootfs_label)..."
    echo "Kernel: $kernel_file"
    echo "Initrd: $initrd_file"

    # Kernel and initrd are on the EFI/boot partition (not rootfs)
    # The rootfs has /boot excluded (--exclude-path boot/ in WKS)
    set root=$boot_partition
    linux $kernel_file root=LABEL=$rootfs_label rootwait console=ttyS0,115200 console=tty0
    initrd $initrd_file
}

# Recovery/fallback entry - always boots slot A
menuentry "n3x Recovery (slot A)" {
    echo "Recovery boot from slot A..."
    set root=$boot_partition
    linux $kernel_file root=LABEL=APP rootwait console=ttyS0,115200 console=tty0
    initrd $initrd_file
}

# Manual slot B entry for testing
menuentry "n3x (force slot B)" {
    echo "Forcing boot from slot B..."
    set root=$boot_partition
    linux $kernel_file root=LABEL=APP_b rootwait console=ttyS0,115200 console=tty0
    initrd $initrd_file
}
