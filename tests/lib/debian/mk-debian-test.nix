# =============================================================================
# mkISARTest - Create NixOS-style VM tests for ISAR images
# =============================================================================
#
# This wraps the nixos-test-driver to work with ISAR-built .wic images.
# It generates run-*-vm scripts and configures the test driver.
#
# Usage:
#   mkISARTest {
#     name = "k3s-cluster";
#     machines = {
#       server = { image = ./server.wic; };
#       agent1 = { image = ./agent.wic; };
#       agent2 = { image = ./agent.wic; };
#     };
#     testScript = ''
#       server.wait_for_unit("multi-user.target")
#       agent1.wait_for_unit("multi-user.target")
#     '';
#   }
#
# =============================================================================

{ pkgs
, lib ? pkgs.lib
,
}:

{
  # Test name
  name
, # Map of machine name -> { image, memory?, cpus?, extraQemuArgs? }
  machines
, # Python test script (same API as NixOS tests)
  testScript
, # VLAN numbers to create (default: [1])
  vlans ? [ 1 ]
, # Global timeout in seconds
  globalTimeout ? 3600
, # Extra arguments for test driver
  extraDriverArgs ? [ ]
,
}:

let
  # Import the VM script generator for ISAR images
  mkISARVMScript = pkgs.callPackage ./mk-debian-vm-script.nix { };

  # Generate a NixOS VM script compatible with the test driver
  # This creates a VM from a NixOS configuration that matches the ISAR test interface
  mkNixOSVMScript = { name, nixosConfig, memory ? 512, cpus ? 1 }:
    let
      # Build a NixOS VM using direct NixOS evaluation
      # We use the NixOS test VM infrastructure which is designed for this purpose
      vmBuild = (pkgs.nixos ({ config, pkgs, lib, modulesPath, ... }: {
        imports = [
          nixosConfig
          # Import the qemu-vm module for VM support
          "${modulesPath}/virtualisation/qemu-vm.nix"
          # Import test-instrumentation for backdoor shell access
          # This provides systemd.services.backdoor and disables getty on hvc0
          "${modulesPath}/testing/test-instrumentation.nix"
        ];

        # VM configuration for test driver compatibility
        virtualisation = {
          memorySize = memory;
          # Note: 'cores' was renamed to 'qemu.cpuCount' or similar in newer nixpkgs
          # Use qemu.options for CPU count
          qemu.options = [
            "-smp ${toString cpus}"
            "-display none"
            "-serial null"
          ];
          graphics = false;
        };

        # Don't wait for network as we configure it manually
        networking.useNetworkd = true;
        networking.useDHCP = false;
      })).config.system.build.vm;
    in
    # Create a wrapper that matches the ISAR VM script interface
    pkgs.symlinkJoin {
      name = "nixos-vm-${name}";
      paths = [
        (pkgs.writeShellScriptBin "run-${name}-vm" ''
          # run-${name}-vm - NixOS VM start script for ISAR hybrid tests
          # Generated by mk-isar-test.nix for NixOS VMs in ISAR test infrastructure

          set -euo pipefail

          # Build network arguments dynamically based on QEMU_VDE_SOCKET_* env vars
          NET_ARGS=""
          for var in $(printenv | grep '^QEMU_VDE_SOCKET_' | sort); do
            VLAN_NUM="''${var#QEMU_VDE_SOCKET_}"
            VLAN_NUM="''${VLAN_NUM%%=*}"
            SOCKET_PATH="''${var#*=}"

            # Generate unique MAC address based on machine name and VLAN number
            NAME_HASH=$(echo -n "${name}" | md5sum | cut -c1-4)
            MAC="52:54:00:''${NAME_HASH:0:2}:''${NAME_HASH:2:2}:$(printf '%02x' "$VLAN_NUM")"

            NET_ARGS="$NET_ARGS -netdev vde,id=vlan$VLAN_NUM,sock=$SOCKET_PATH"
            NET_ARGS="$NET_ARGS -device virtio-net-pci,netdev=vlan$VLAN_NUM,mac=$MAC"
          done

          # Launch the NixOS VM with VDE network support
          # The run-*-vm script already handles QEMU setup, we just add networking
          exec ${vmBuild}/bin/run-*-vm $NET_ARGS "$@"
        '')
      ];
    };

  # Generate VM scripts for each machine
  # Supports both ISAR images (image attr) and NixOS VMs (nixosConfig attr)
  # ISAR VMs support bootMode (Plan 020 F2): "firmware" (default) or "direct"
  vmScripts = lib.mapAttrs
    (machineName: machineConfig:
      if machineConfig ? nixosConfig then
        # NixOS VM
        mkNixOSVMScript {
          name = machineName;
          inherit (machineConfig) nixosConfig;
          memory = machineConfig.memory or 512;
          cpus = machineConfig.cpus or 1;
        }
      else
        # ISAR VM - supports bootMode for direct kernel boot (Plan 020 F2)
        mkISARVMScript ({
          name = machineName;
          image = machineConfig.image;
          memory = machineConfig.memory or 4096;
          cpus = machineConfig.cpus or 4;
          extraQemuArgs = machineConfig.extraQemuArgs or [ ];
        } // lib.optionalAttrs (machineConfig ? bootMode) {
          inherit (machineConfig) bootMode;
        } // lib.optionalAttrs (machineConfig ? kernel) {
          inherit (machineConfig) kernel;
        } // lib.optionalAttrs (machineConfig ? initrd) {
          inherit (machineConfig) initrd;
        } // lib.optionalAttrs (machineConfig ? kernelParams) {
          inherit (machineConfig) kernelParams;
        })
    )
    machines;

  # Build the test driver directly (avoid circular dependency via nixosTests)
  #
  # API NOTE: The nixpkgs test-driver interface changed between master and 25.11.
  # On 25.11, python3Packages is passed as a single attrset (not individual packages).
  # If you see errors about unexpected arguments after nixpkgs updates,
  # check ${pkgs.path}/nixos/lib/test-driver/default.nix for the current interface.
  testDriver = pkgs.callPackage "${pkgs.path}/nixos/lib/test-driver" {
    inherit (pkgs) coreutils netpbm socat vde2 ruff;
    inherit (pkgs) python3Packages;
    qemu_pkg = pkgs.qemu_test;
    qemu_test = pkgs.qemu_test;
    imagemagick_light = pkgs.imagemagick_light;
    tesseract4 = pkgs.tesseract4;
    # Pass null for nixosTests to break the circular dependency
    # The test driver doesn't actually need this at runtime
    nixosTests = null;
  };

  # Collect all VM script paths
  vmStartScripts = lib.mapAttrsToList
    (name: script:
      "${script}/bin/run-${name}-vm"
    )
    vmScripts;

  # Write the test script to a file
  # Note: We pass the testScript directly without manual indentation stripping.
  # The Python code is assembled from interpolated Nix strings at various indentation
  # levels, including code at column 0 (like utils.all function definitions).
  # Manual stripping breaks this - let Python handle any trivial whitespace.
  testScriptFile = pkgs.writeText "test-script" testScript;

  # Create the wrapped test driver
  wrappedDriver = pkgs.runCommand "debian-test-driver-${name}"
    {
      nativeBuildInputs = [ pkgs.makeWrapper ];
      passthru = {
        inherit vmScripts testDriver;
        # Allow running interactively
        driverInteractive = wrappedDriver;
      };
    } ''
    mkdir -p $out/bin

    # Create wrapper with proper command-line arguments
    makeWrapper ${testDriver}/bin/nixos-test-driver $out/bin/nixos-test-driver \
      --add-flags "--start-scripts ${lib.concatStringsSep " " vmStartScripts}" \
      --add-flags "--vlans ${toString vlans}" \
      --add-flags "--global-timeout ${toString globalTimeout}" \
      --add-flags "${testScriptFile}" \
      ${lib.optionalString (extraDriverArgs != [])
        (lib.concatMapStringsSep " " (arg: "--add-flags ${lib.escapeShellArg arg}") extraDriverArgs)}

    # Create convenience script
    cat > $out/bin/run-test <<SCRIPT
    #!${pkgs.bash}/bin/bash
    exec "\$(dirname "\$0")/nixos-test-driver" "\$@"
    SCRIPT
    chmod +x $out/bin/run-test

    # Create interactive script
    cat > $out/bin/run-test-interactive <<SCRIPT
    #!${pkgs.bash}/bin/bash
    exec "\$(dirname "\$0")/nixos-test-driver" --interactive "\$@"
    SCRIPT
    chmod +x $out/bin/run-test-interactive
  '';

  # Create the test derivation (runs the test in a sandbox)
  test = pkgs.runCommand "debian-test-${name}"
    {
      nativeBuildInputs = [ wrappedDriver ];
      # These are needed for QEMU
      requiredSystemFeatures = [ "kvm" ];
    } ''
    mkdir -p $out
    export TMPDIR=$(mktemp -d)
    trap 'rm -rf "$TMPDIR"' EXIT

    # Run the test
    nixos-test-driver 2>&1 | tee $out/test.log

    # Mark success
    touch $out/passed
  '';

in
{
  # The test derivation (sandboxed, for CI)
  inherit test;

  # The driver (for interactive use)
  driver = wrappedDriver;

  # Individual VM scripts (for manual testing)
  inherit vmScripts;
}
