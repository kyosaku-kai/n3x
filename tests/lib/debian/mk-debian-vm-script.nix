# =============================================================================
# mkISARVMScript - Generate VM start scripts for ISAR images
# =============================================================================
#
# Creates run-<name>-vm scripts compatible with nixos-test-driver.
# These scripts launch QEMU with the specified ISAR .wic image.
#
# BOOT MODES (Plan 020 F2):
#   - "firmware": UEFI boot via OVMF → bootloader (GRUB/systemd-boot) → kernel
#     Tests full boot sequence, hardware fidelity, bootloader configuration
#   - "direct": Direct kernel boot via -kernel/-initrd QEMU flags
#     Faster boot, bypasses bootloader, guaranteed backdoor compatibility
#
# VLAN Support:
#   When run from nixos-test-driver with --vlans, the test driver sets
#   QEMU_VDE_SOCKET_{nr} environment variables for each VLAN. This script
#   automatically detects these and adds virtio-net-pci devices connected
#   to the VDE switches.
#
# Usage:
#   mkISARVMScript {
#     name = "server";
#     image = ./path/to/image.wic;
#     bootMode = "direct";  # or "firmware" (default)
#     kernel = ./path/to/vmlinuz;  # required for direct boot
#     initrd = ./path/to/initrd.img;  # required for direct boot
#   }
#
# Output:
#   A derivation containing bin/run-<name>-vm
#
# =============================================================================

{ writeShellScriptBin
, qemu_kvm
, OVMF
, runCommand
, coreutils
, lib
, symlinkJoin
,
}:

{
  # Machine name - will be used in run-<name>-vm
  name
, # Path to .wic image file
  image
, # Memory in MB
  memory ? 4096
, # Number of CPUs
  cpus ? 4
, # Boot mode: "firmware" (UEFI/OVMF) or "direct" (kernel/initrd)
  bootMode ? "firmware"
, # Path to kernel (vmlinuz) - required for direct boot
  kernel ? null
, # Path to initrd - required for direct boot
  initrd ? null
, # Kernel command line for direct boot (merged with defaults)
  kernelParams ? null
, # Additional QEMU arguments
  extraQemuArgs ? [ ]
,
}:

let
  # Validate boot mode
  _ = assert bootMode == "firmware" || bootMode == "direct";
    assert bootMode == "firmware" || (kernel != null && initrd != null);
    null;

  # OVMF paths (for firmware boot)
  ovmfCode = "${OVMF.fd}/FV/OVMF_CODE.fd";
  ovmfVarsSource = "${OVMF.fd}/FV/OVMF_VARS.fd";

  # Default kernel parameters for direct boot
  # These match the ISAR WKS kernel cmdline for compatibility
  defaultKernelParams = lib.concatStringsSep " " [
    "root=/dev/vda2" # Root partition on virtio disk
    "rootwait" # Wait for root device
    "console=ttyS0,115200" # Serial console for QEMU
    "net.ifnames=0" # Legacy eth* naming (required for test driver)
    "biosdevname=0" # Disable BIOS device naming
    "quiet" # Reduce boot verbosity
    "loglevel=1" # Minimize kernel messages (hvc0 cleanliness)
  ];

  # Use user-provided kernel params or defaults
  effectiveKernelParams = if kernelParams != null then kernelParams else defaultKernelParams;

  # Generate firmware boot script (UEFI via OVMF)
  firmwareBootSetup = ''
    # Create a temporary copy of OVMF_VARS (it gets modified during boot)
    OVMF_VARS=$(${coreutils}/bin/mktemp --suffix=.fd)
    trap '${coreutils}/bin/rm -f "$OVMF_VARS"' EXIT
    ${coreutils}/bin/cp "${ovmfVarsSource}" "$OVMF_VARS"
    ${coreutils}/bin/chmod 644 "$OVMF_VARS"
    echo "DEBUG: Boot mode: firmware (UEFI via OVMF)" >&2
  '';

  # Generate direct kernel boot setup
  directBootSetup = ''
    echo "DEBUG: Boot mode: direct (kernel/initrd)" >&2
    echo "DEBUG: Kernel: ${kernel}" >&2
    echo "DEBUG: Initrd: ${initrd}" >&2
    echo "DEBUG: Cmdline: ${effectiveKernelParams}" >&2
  '';

  # QEMU boot arguments differ by mode
  firmwareBootArgs = ''
    -drive if=pflash,format=raw,readonly=on,file="${ovmfCode}" \
    -drive if=pflash,format=raw,file="$OVMF_VARS" \'';

  directBootArgs = ''
    -kernel "${kernel}" \
    -initrd "${initrd}" \
    -append "${effectiveKernelParams}" \'';

  # Select boot setup and args based on mode
  bootSetup = if bootMode == "direct" then directBootSetup else firmwareBootSetup;
  bootArgs = if bootMode == "direct" then directBootArgs else firmwareBootArgs;

  # Script using writeShellScriptBin for proper nix shebang handling
  vmScript = writeShellScriptBin "run-${name}-vm" ''
        # run-${name}-vm - ISAR VM start script for nixos-test-driver
        # Generated by mkISARVMScript
        # Boot mode: ${bootMode}

        set -euo pipefail

        ${bootSetup}

        # Build network arguments dynamically based on QEMU_VDE_SOCKET_* env vars
        # These are set by nixos-test-driver's VLan class when --vlans is used
        #
        # NixOS test driver convention:
        #   eth0 = Default network (NAT/slirp for internet access)
        #   eth1+ = VLAN networks from --vlans argument
        #
        # To match this convention, we add a disconnected eth0 placeholder
        # so that VDE VLAN networks start at eth1.
        NET_ARGS="-netdev user,id=net0,restrict=on -device virtio-net-pci,netdev=net0,mac=52:54:00:00:00:00"
        echo "DEBUG: Looking for QEMU_VDE_SOCKET_* environment variables..." >&2
        echo "DEBUG: All QEMU env vars: $(printenv | grep -i qemu || echo 'none')" >&2
        for var in $(printenv | grep '^QEMU_VDE_SOCKET_' | sort); do
          VLAN_NUM="''${var#QEMU_VDE_SOCKET_}"
          VLAN_NUM="''${VLAN_NUM%%=*}"
          SOCKET_PATH="''${var#*=}"

          # Generate unique MAC address based on machine name and VLAN number
          # Use hash of name to get consistent but unique MAC per machine
          NAME_HASH=$(echo -n "${name}" | md5sum | cut -c1-4)
          MAC="52:54:00:''${NAME_HASH:0:2}:''${NAME_HASH:2:2}:$(printf '%02x' "$VLAN_NUM")"

          echo "DEBUG: Found VLAN $VLAN_NUM, socket=$SOCKET_PATH, MAC=$MAC" >&2
          NET_ARGS="$NET_ARGS -netdev vde,id=vlan$VLAN_NUM,sock=$SOCKET_PATH"
          NET_ARGS="$NET_ARGS -device virtio-net-pci,netdev=vlan$VLAN_NUM,mac=$MAC"
        done
        echo "DEBUG: Final NET_ARGS=$NET_ARGS" >&2

        # Launch QEMU
        # Note: nixos-test-driver appends additional arguments for:
        #   - virtio-serial and virtconsole (backdoor shell)
        #   - QMP socket
        #   - Monitor socket
        #   - Shell chardev socket
        # Serial port redirected to null - GRUB uses serial for console output
        # but we don't need to capture it. The backdoor uses virtconsole instead.
        exec ${qemu_kvm}/bin/qemu-system-x86_64 \
          -machine q35 \
          -cpu host \
          -enable-kvm \
          -m ${toString memory} \
          -smp ${toString cpus} \
          -display none \
          -serial null \
    ${bootArgs}
          -drive file="${image}",format=raw,if=virtio,snapshot=on \
          $NET_ARGS \
          ${lib.escapeShellArgs extraQemuArgs} \
          "$@"
  '';

  # Wrap in a derivation with a name that does NOT contain "run-...-vm" pattern
  # The nixos-test-driver regex `run-(.+)-vm$` would otherwise match the store path
in
symlinkJoin {
  name = "debian-vm-${name}";
  paths = [ vmScript ];
}
