# =============================================================================
# mkISARVMScript - Generate VM start scripts for ISAR images
# =============================================================================
#
# Creates run-<name>-vm scripts compatible with nixos-test-driver.
# These scripts launch QEMU with the specified ISAR .wic image.
#
# VLAN Support:
#   When run from nixos-test-driver with --vlans, the test driver sets
#   QEMU_VDE_SOCKET_{nr} environment variables for each VLAN. This script
#   automatically detects these and adds virtio-net-pci devices connected
#   to the VDE switches.
#
# Usage:
#   mkISARVMScript {
#     name = "server";
#     image = ./path/to/image.wic;
#   }
#
# Output:
#   A derivation containing bin/run-<name>-vm
#
# =============================================================================

{ writeShellScriptBin
, qemu_kvm
, OVMF
, runCommand
, coreutils
, lib
, symlinkJoin
,
}:

{
  # Machine name - will be used in run-<name>-vm
  name
, # Path to .wic image file
  image
, # Memory in MB
  memory ? 4096
, # Number of CPUs
  cpus ? 4
, # Additional QEMU arguments
  extraQemuArgs ? [ ]
,
}:

let
  # OVMF paths
  ovmfCode = "${OVMF.fd}/FV/OVMF_CODE.fd";
  ovmfVarsSource = "${OVMF.fd}/FV/OVMF_VARS.fd";

  # Script using writeShellScriptBin for proper nix shebang handling
  vmScript = writeShellScriptBin "run-${name}-vm" ''
    # run-${name}-vm - ISAR VM start script for nixos-test-driver
    # Generated by mkISARVMScript

    set -euo pipefail

    # Create a temporary copy of OVMF_VARS (it gets modified during boot)
    OVMF_VARS=$(${coreutils}/bin/mktemp --suffix=.fd)
    trap '${coreutils}/bin/rm -f "$OVMF_VARS"' EXIT
    ${coreutils}/bin/cp "${ovmfVarsSource}" "$OVMF_VARS"
    ${coreutils}/bin/chmod 644 "$OVMF_VARS"

    # Build network arguments dynamically based on QEMU_VDE_SOCKET_* env vars
    # These are set by nixos-test-driver's VLan class when --vlans is used
    NET_ARGS=""
    echo "DEBUG: Looking for QEMU_VDE_SOCKET_* environment variables..." >&2
    echo "DEBUG: All QEMU env vars: $(printenv | grep -i qemu || echo 'none')" >&2
    for var in $(printenv | grep '^QEMU_VDE_SOCKET_' | sort); do
      VLAN_NUM="''${var#QEMU_VDE_SOCKET_}"
      VLAN_NUM="''${VLAN_NUM%%=*}"
      SOCKET_PATH="''${var#*=}"

      # Generate unique MAC address based on machine name and VLAN number
      # Use hash of name to get consistent but unique MAC per machine
      NAME_HASH=$(echo -n "${name}" | md5sum | cut -c1-4)
      MAC="52:54:00:''${NAME_HASH:0:2}:''${NAME_HASH:2:2}:$(printf '%02x' "$VLAN_NUM")"

      echo "DEBUG: Found VLAN $VLAN_NUM, socket=$SOCKET_PATH, MAC=$MAC" >&2
      NET_ARGS="$NET_ARGS -netdev vde,id=vlan$VLAN_NUM,sock=$SOCKET_PATH"
      NET_ARGS="$NET_ARGS -device virtio-net-pci,netdev=vlan$VLAN_NUM,mac=$MAC"
    done
    echo "DEBUG: Final NET_ARGS=$NET_ARGS" >&2

    # Launch QEMU
    # Note: nixos-test-driver appends additional arguments for:
    #   - virtio-serial and virtconsole (backdoor shell)
    #   - QMP socket
    #   - Monitor socket
    #   - Shell chardev socket
    # Serial port redirected to null - GRUB uses serial for console output
    # but we don't need to capture it. The backdoor uses virtconsole instead.
    exec ${qemu_kvm}/bin/qemu-system-x86_64 \
      -machine q35 \
      -cpu host \
      -enable-kvm \
      -m ${toString memory} \
      -smp ${toString cpus} \
      -display none \
      -serial null \
      -drive if=pflash,format=raw,readonly=on,file="${ovmfCode}" \
      -drive if=pflash,format=raw,file="$OVMF_VARS" \
      -drive file="${image}",format=raw,if=virtio,snapshot=on \
      $NET_ARGS \
      ${lib.escapeShellArgs extraQemuArgs} \
      "$@"
  '';

  # Wrap in a derivation with a name that does NOT contain "run-...-vm" pattern
  # The nixos-test-driver regex `run-(.+)-vm$` would otherwise match the store path
in
symlinkJoin {
  name = "isar-vm-${name}";
  paths = [ vmScript ];
}
