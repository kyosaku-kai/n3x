# =============================================================================
# mk-systemd-networkd.nix - Generate systemd-networkd configuration files
# =============================================================================
#
# This module generates .network and .netdev file content from network profiles.
# Used by BOTH backends:
#   - NixOS: Content matches what systemd.network.* options generate
#   - ISAR: Generated files installed directly to /etc/systemd/network/
#
# USAGE:
#   mkNetworkd = import ./mk-systemd-networkd.nix { inherit lib; };
#
#   # Generate all files for a profile
#   files = mkNetworkd.generateProfileFiles profile "server-1";
#   # Returns: { "20-eth1.network" = "..."; "15-trunk.network" = "..."; ... }
#
# =============================================================================

{ lib }:

let
  # Helper to format INI-style section
  formatSection = name: content:
    "[${name}]\n${content}";

  # Helper to format key=value, filtering out nulls and empty strings
  formatKeyValue = attrs:
    lib.pipe attrs [
      (lib.filterAttrs (_: v: v != null && v != ""))
      (lib.mapAttrsToList (k: v: "${k}=${toString v}"))
      (lib.concatStringsSep "\n")
    ];

in
rec {
  # =========================================================================
  # Generate .network file content
  # =========================================================================
  #
  # A .network file matches interfaces and configures them.
  #
  # Example output:
  #   [Match]
  #   Name=eth1
  #
  #   [Network]
  #   DHCP=no
  #   Address=192.168.1.1/24
  #
  mkNetworkFile =
    { name
    , # Interface name to match (e.g., "eth1", "eth1.200")
      addresses ? [ ]
    , # List of "ip/prefix" (e.g., ["192.168.1.1/24"])
      priority ? 20
    , # File priority (lower = earlier in sort order)
      vlans ? [ ]
    , # VLAN interfaces to create on this trunk
      dhcp ? "no"
    , ipv6AcceptRA ? false
    , linkLocalAddressing ? "no"
    , gateway ? null
    , # Default gateway (optional)
    }:
    let
      matchSection = formatSection "Match" (formatKeyValue {
        Name = name;
      });

      networkKV = {
        DHCP = dhcp;
        IPv6AcceptRA = if ipv6AcceptRA then "yes" else "no";
        LinkLocalAddressing = linkLocalAddressing;
      }
      // lib.optionalAttrs (gateway != null) { Gateway = gateway; };

      # Addresses and VLANs need special handling (multiple entries)
      addressLines = lib.concatMapStrings (addr: "Address=${addr}\n") addresses;
      vlanLines = lib.concatMapStrings (vlan: "VLAN=${vlan}\n") vlans;

      networkSection = formatSection "Network" ''
        ${formatKeyValue networkKV}
        ${addressLines}${vlanLines}'';

    in
    ''
      # Generated by n3x lib/network/mk-systemd-networkd.nix
      # Do not edit manually - regenerate with: nix run '.#generate-networkd-configs'

      ${matchSection}

      ${networkSection}
    '';

  # =========================================================================
  # Generate .netdev file for VLAN
  # =========================================================================
  #
  # Example output:
  #   [NetDev]
  #   Name=eth1.200
  #   Kind=vlan
  #
  #   [VLAN]
  #   Id=200
  #
  mkVlanNetdev = { name, id }:
    let
      netdevSection = formatSection "NetDev" (formatKeyValue {
        Name = name;
        Kind = "vlan";
      });

      vlanSection = formatSection "VLAN" (formatKeyValue {
        Id = toString id;
      });

    in
    ''
      # Generated by n3x lib/network/mk-systemd-networkd.nix
      # Do not edit manually - regenerate with: nix run '.#generate-networkd-configs'

      ${netdevSection}

      ${vlanSection}
    '';

  # =========================================================================
  # Generate .netdev file for bond
  # =========================================================================
  #
  # Example output:
  #   [NetDev]
  #   Name=bond0
  #   Kind=bond
  #
  #   [Bond]
  #   Mode=802.3ad
  #   MIIMonitorSec=100ms
  #
  mkBondNetdev =
    { name
    , mode ? "802.3ad"
    , miiMonitorSec ? "100ms"
    , lacpRate ? "fast"
    ,
    }:
    let
      netdevSection = formatSection "NetDev" (formatKeyValue {
        Name = name;
        Kind = "bond";
      });

      bondSection = formatSection "Bond" (formatKeyValue {
        Mode = mode;
        MIIMonitorSec = miiMonitorSec;
        LACPTransmitRate = lacpRate;
      });

    in
    ''
      # Generated by n3x lib/network/mk-systemd-networkd.nix
      # Do not edit manually - regenerate with: nix run '.#generate-networkd-configs'

      ${netdevSection}

      ${bondSection}
    '';

  # =========================================================================
  # Generate .network file for bond slave interface
  # =========================================================================
  #
  # Example output:
  #   [Match]
  #   Name=eth1
  #
  #   [Network]
  #   Bond=bond0
  #
  mkBondSlaveNetwork = { name, bond, primarySlave ? false }:
    let
      matchSection = formatSection "Match" (formatKeyValue {
        Name = name;
      });

      networkSection = formatSection "Network" (formatKeyValue {
        Bond = bond;
      });

      # If primary slave, add link section
      linkSection = lib.optionalString primarySlave (formatSection "Link" (formatKeyValue {
        RequiredForOnline = "no";
      }));

    in
    ''
      # Generated by n3x lib/network/mk-systemd-networkd.nix
      # Do not edit manually - regenerate with: nix run '.#generate-networkd-configs'

      ${matchSection}

      ${networkSection}
      ${linkSection}
    '';

  # =========================================================================
  # Generate all files for a profile and node
  # =========================================================================
  #
  # This is the main entry point. Given a profile and node name, it generates
  # all necessary .network and .netdev files.
  #
  # Returns: { filename = content; }
  #
  # Profile detection:
  #   - Has vlanIds? → VLAN profile
  #   - Has bondConfig? → Bonding profile
  #   - Otherwise → Simple flat network
  #
  generateProfileFiles = profile: nodeName:
    let
      # Extract profile data
      interfaces = profile.interfaces or { };
      ipAddresses = profile.ipAddresses or { };
      vlanIds = profile.vlanIds or null;
      nodeIPs = ipAddresses.${nodeName} or { };

      # Detect profile type
      # - hasVlans: profile defines vlanIds
      # - hasBond: profile defines bond interface (vlans profile has trunk but not bond/bondMembers)
      hasVlans = vlanIds != null;
      hasBond = interfaces ? bond || interfaces ? bondMembers;

      # Simple profile: single interface with direct IP
      simpleFiles = lib.optionalAttrs (!hasVlans && !hasBond) {
        "20-${interfaces.cluster or "eth1"}.network" = mkNetworkFile {
          name = interfaces.cluster or "eth1";
          addresses = [ "${nodeIPs.cluster or "0.0.0.0"}/24" ];
        };
      };

      # VLAN profile helper values
      vlanTrunk = interfaces.trunk or "eth1";
      vlanClusterIface = interfaces.cluster or "eth1.200";
      vlanStorageIface = interfaces.storage or null;
      vlanClusterId = if vlanIds != null then vlanIds.cluster or 200 else 200;
      vlanStorageId = if vlanIds != null then vlanIds.storage or null else null;

      # VLAN profile: trunk interface + VLAN interfaces
      vlanFiles =
        if (hasVlans && !hasBond) then
          {
            # Trunk interface (no IP, just carries VLANs)
            "15-${vlanTrunk}.network" = mkNetworkFile {
              name = vlanTrunk;
              addresses = [ ];
              priority = 15;
              vlans = [ vlanClusterIface ] ++ lib.optional (vlanStorageIface != null) vlanStorageIface;
            };

            # Cluster VLAN netdev
            "20-vlan-cluster.netdev" = mkVlanNetdev {
              name = vlanClusterIface;
              id = vlanClusterId;
            };

            # Cluster VLAN network
            "20-vlan-cluster.network" = mkNetworkFile {
              name = vlanClusterIface;
              addresses = [ "${nodeIPs.cluster or "0.0.0.0"}/24" ];
            };
          }
          // lib.optionalAttrs (vlanStorageIface != null) {
            # Storage VLAN netdev
            "20-vlan-storage.netdev" = mkVlanNetdev {
              name = vlanStorageIface;
              id = vlanStorageId;
            };

            # Storage VLAN network
            "20-vlan-storage.network" = mkNetworkFile {
              name = vlanStorageIface;
              addresses = [ "${nodeIPs.storage or "0.0.0.0"}/24" ];
            };
          }
        else { };

      # Bonding profile helper values
      bondIface = interfaces.trunk or (interfaces.bond or "bond0");
      bondSlaves = interfaces.bondMembers or (interfaces.bondSlaves or [ "eth1" "eth2" ]);
      bondClusterVlan = interfaces.cluster or "${bondIface}.200";
      bondStorageVlan = interfaces.storage or null;
      bondClusterId = if vlanIds != null then vlanIds.cluster or 200 else 200;
      bondStorageId = if vlanIds != null then vlanIds.storage or null else null;

      # Bonding + VLAN profile (most complex)
      bondingVlanFiles =
        if (hasVlans && hasBond) then
          {
            # Bond netdev
            "10-${bondIface}.netdev" = mkBondNetdev { name = bondIface; };

            # Bond network (trunk for VLANs)
            "15-${bondIface}.network" = mkNetworkFile {
              name = bondIface;
              addresses = [ ];
              priority = 15;
              vlans = [ bondClusterVlan ] ++ lib.optional (bondStorageVlan != null) bondStorageVlan;
            };
          }
          // lib.listToAttrs (lib.imap0
            (i: slave: {
              name = "10-${slave}.network";
              value = mkBondSlaveNetwork {
                name = slave;
                bond = bondIface;
                primarySlave = i == 0;
              };
            })
            bondSlaves)
          // {
            # Cluster VLAN netdev
            "20-vlan-cluster.netdev" = mkVlanNetdev {
              name = bondClusterVlan;
              id = bondClusterId;
            };

            # Cluster VLAN network
            "20-vlan-cluster.network" = mkNetworkFile {
              name = bondClusterVlan;
              addresses = [ "${nodeIPs.cluster or "0.0.0.0"}/24" ];
            };
          }
          // lib.optionalAttrs (bondStorageVlan != null) {
            # Storage VLAN netdev
            "20-vlan-storage.netdev" = mkVlanNetdev {
              name = bondStorageVlan;
              id = bondStorageId;
            };

            # Storage VLAN network
            "20-vlan-storage.network" = mkNetworkFile {
              name = bondStorageVlan;
              addresses = [ "${nodeIPs.storage or "0.0.0.0"}/24" ];
            };
          }
        else { };

    in
    simpleFiles // vlanFiles // bondingVlanFiles;

  # =========================================================================
  # Generate files for all nodes in a profile
  # =========================================================================
  #
  # Returns: { nodeName = { filename = content; }; }
  #
  generateAllNodeFiles = profile:
    let
      nodeNames = lib.attrNames (profile.ipAddresses or { });
    in
    lib.genAttrs nodeNames (nodeName: generateProfileFiles profile nodeName);
}
